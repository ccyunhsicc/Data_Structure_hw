# Entanglement Routing & Numerology Selection（量子網路資料傳輸排程）作業

## 作業簡介

模擬量子網路中的**糾纏路由**與**策略樹（numerology）**選擇問題：在節點具有限制的量子記憶體、邊視為光纖通道充足的前提下，於給定的時間槽 (T) 內，對多組來源–目的地（SD）需求進行是否接受的決策，並為被接受者找出**路徑**與**（以完全二元樹表示的）策略樹**，使每個時間點的節點記憶體使用量不超過上限，且最大化被接受需求數量。評分與基準演算法說明見題目。 

---

## 檔案一覽

* `program3.pdf`：作業說明（題目、格式、評分辦法、基準法）。 
* `411410054_hw3.c`：主程式（BFS 路徑搜尋、排程與輸出）。 

---

## 建置與執行

### 編譯

```bash
gcc 411410054_hw3.c -o hw3.exe
```

### 執行

```bash
./hw3.exe 
```

---

## 輸入格式（`stdin`）

```
#Nodes  #Links  #TimeSlots  #Req
NodeID  #QuantumMemories
...
LinkID  LinkEnd1  LinkEnd2
...
ReqID   ReqSrc    ReqDst
...
```

* 節點行給出每個節點的**量子記憶體數**；
* 邊行以**無向**連結建立圖；
* 需求行列出每筆 SD 請求（來源與目的）。
* 題目 PDF 提供完整範例與說明。 

---

## 輸出格式（`stdout`）

```
#AccReq
<每一筆被接受之需求的描述塊（路徑＋樹結構）>
```

* 第一行為**被接受的需求數量** `#AccReq`。
* 對每個被接受的需求，程式會先輸出一行概要，接著輸出其**樹結構（postorder）**所需的操作與時間：

  * **一跳請求（路徑長度 = 1）**

    ```
    ReqID ReqSrc ReqDst
    ReqSrc ReqDst t_start
    ```
  * **多跳請求（路徑長度 ≥ 2）**

    ```
    ReqID <route_node_0> <route_node_1> ... <route_node_k>
    u v t          # entangling（在時間 t 建立 u–v）
    a b a c c b t' # swapping（以題目「樹結構」格式輸出）
    ...
    ```

  實際輸出欄位順序與時間遞進，符合題目所述「樹結構（postorder）」格式；完整定義見 PDF。  

---

## 方法摘要

### 1) 路徑搜尋（BFS）

對每筆需求以 **BFS** 在原圖上找**最少跳數路徑**，並回填 `parent[]` 重建路徑到陣列 `req_route[]`。每次 BFS 皆重新初始化 `visit[]` 與 `parent[]`，以避免殘留影響。 

> 基準演算法亦指定以 BFS 尋找最短路徑；若遇到路徑同長，題目建議以較小節點 ID 優先作為 tie-break（本實作依輸入建圖順序決定鄰接掃描次序）。 

### 2) 策略樹與時序安排（Numerology & Scheduling）

* 依題目基準法，採用**完全二元樹**（葉節點位於最早時間層），並以**後序（postorder）**輸出對應的 **entangling** 與 **swapping** 步驟。 
* 程式以**貪婪**方式由時間 `t = 2` 起逐槽嘗試安置每筆需求：先檢查沿路各節點在對應時間是否仍有足夠**量子記憶體**，若可行則：

  * 一跳需求：在 `t` 與 `t+1` 佔用端點記憶體並輸出一步操作；
  * 多跳需求：沿路徑逐段安排 entangling 與交換所需的節點記憶體占用（起點、中繼、終點用量分別以 1/2/1 的模式在不同時間疊加），並輸出對應操作行。
* 若在 `T` 內無法完成，該需求將被拒絕。 

---

## 資料結構與重要函式

* **圖結構**：以 adjacency list 表示（`struct graph_node* list[]`），`add_graph_link()` 建立**無向邊**。 
* **佇列**：自訂鏈結串列 `queue_push()/queue_pop()` 供 BFS 使用。 
* **BFS**：`BFS(start, end, num)` 回傳最短跳數並重建 `req_route[]` 作為後續排程依據。 
* **時間 × 記憶體表**：`node_time_memory[time][node]` 追蹤各時間槽之節點記憶體占用，用以檢驗可行性。 

---

## 複雜度

* 路徑搜尋：單次 **BFS = O(|V|+|E|)**，全部需求為 (O(#Req\cdot(|V|+|E|)))。
* 排程檢核：對可行路徑長度 (k)，時間維度檢查為 (O(k))；總體約 (O(#Req\cdot k))。 

---

## 注意事項

* **通道足夠**：依題意假設光纖通道容量充足，不考慮失敗率與策略樹高度對品質之影響（本作業不納入）。 
* **起始時間**：實作自 `t = 2` 開始安排操作；若需求在 `T` 內無法完成即拒絕。 
* **公平性**：採逐時間槽與逐需求掃描的貪婪策略，**無全域最佳化保證**；目標為盡量提高被接受需求數。 
